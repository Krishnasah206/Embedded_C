/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "stm32f446xx.h"
#include <string.h>
#include <stdio.h>
#include "pll.h"
#include "sysTick.h"

// Function prototypes
void DAC_Init(void);
void DAC_SetValue(uint32_t value);
void UART_Init(void);
void UART_Transmit(char *string);
void UART_Receive(char *buffer, uint32_t length);
void Button_Init(void);
void LED_Init(void);
void LED_SetIntensity(uint32_t value);
void EXTI15_10_IRQHandler(void);
uint32_t Calculate_nCr(uint32_t n, uint32_t r);

// Global variables
volatile uint32_t ms_ticks = 0;
volatile uint32_t dac_value = 0;
char uart_buffer[100];
char command_buffer[100];

int main(void)
{
    // Initialize peripherals
    SysTick_Init();
    UART_Init();
    DAC_Init();
    Button_Init();
    LED_Init();

    // Welcome message
    UART_Transmit("Utility\r\n1. Print nCr value\r\n2. Increment DAC Value\r\n3. Exit\r\n");

    while (1)
    {
        // Clear command buffer
        memset(command_buffer, 0, sizeof(command_buffer));

        // Receive command from UART
        UART_Transmit("Enter command: \r\n");
        UART_Receive(command_buffer, sizeof(command_buffer));

        if (strncmp(command_buffer, "1", 1) == 0)
        {
            uint32_t n, r;
            UART_Transmit("Enter n: \r\n");
            UART_Receive(command_buffer, sizeof(command_buffer));
            sscanf(command_buffer, "%lu", &n);
            UART_Transmit("Enter r: \r\n");
            UART_Receive(command_buffer, sizeof(command_buffer));
            sscanf(command_buffer, "%lu", &r);

            uint32_t result = Calculate_nCr(n, r);
            sprintf(uart_buffer, "nCr(%lu, %lu) = %lu\r\n", n, r, result);
            UART_Transmit(uart_buffer);
        }
        else if (strncmp(command_buffer, "2", 1) == 0)
        {
            UART_Transmit("Incrementing DAC Value. Press button to increment. Type 'exit' to stop.\r\n");
            DAC_SetValue(dac_value);
            LED_SetIntensity(dac_value);

            while (1)
            {
                // Check for exit command
                UART_Receive(command_buffer, sizeof(command_buffer));
                if (strncmp(command_buffer, "exit", 4) == 0)
                {
                    UART_Transmit("Stopping DAC value increment.\r\n");
                    break;
                }

            }
        }
        else if (strncmp(command_buffer, "3", 1) == 0)
        {
            UART_Transmit("Exiting utility.\r\n");
            break;
        }
        else
        {
            UART_Transmit("Invalid command. Try again.\r\n");
        }
    }

    while (1)
    {
        // Main loop
    }
}



void DAC_Init(void)
{
    // Enable DAC and GPIO clocks
    RCC->APB1ENR |= RCC_APB1ENR_DACEN;
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;

    // Configure PA4 as analog
    GPIOA->MODER |= (0x3 << (4 * 2)); // Analog mode

    // Configure DAC
    DAC->CR |= DAC_CR_EN1; // Enable DAC channel 1
}

void DAC_SetValue(uint32_t value)
{
    DAC->DHR12R1 = value & 0xFFF; // Set 12-bit right-aligned value
    DAC->SWTRIGR |= DAC_SWTRIGR_SWTRIG1; // Trigger the DAC
}

void Button_Init(void)
{
    // Enable GPIO and SYSCFG clocks
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOCEN;
    RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;

    // Configure PC13 as input (User button on Nucleo board)
    GPIOC->MODER &= ~(0x3 << (13 * 2)); // Input mode
    GPIOC->PUPDR |= (0x1 << (13 * 2)); // Pull-up

    // Configure EXTI for PC13
    SYSCFG->EXTICR[3] |= SYSCFG_EXTICR4_EXTI13_PC;
    EXTI->IMR |= EXTI_IMR_MR13; // Unmask EXTI13
    EXTI->FTSR |= EXTI_FTSR_TR13; // Trigger on falling edge

    // Enable EXTI15_10 interrupt
    NVIC_EnableIRQ(EXTI15_10_IRQn);
}

void LED_Init(void)
{
    // Enable GPIO clock
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;

    // Configure PA5 as output (LED)
    GPIOA->MODER |= (0x1 << (5 * 2)); // Output mode
    GPIOA->OTYPER &= ~(0x1 << 5); // Push-pull
    GPIOA->OSPEEDR |= (0x3 << (5 * 2)); // High speed
    GPIOA->PUPDR &= ~(0x3 << (5 * 2)); // No pull-up/pull-down
}

void LED_SetIntensity(uint32_t value)
{
    if (value > 2048)
    {
        GPIOA->BSRR |= GPIO_BSRR_BS_5; // Turn on LED
    }
    else
    {
        GPIOA->BSRR |= GPIO_BSRR_BR_5; // Turn off LED
    }
}


void EXTI15_10_IRQHandler(void)
{
    if (EXTI->PR & EXTI_PR_PR13)
    {
        // Clear pending bit
        EXTI->PR |= EXTI_PR_PR13;

        // Increment DAC value
        dac_value = (dac_value + 100) % 4096; // Increment and wrap-around DAC value
        DAC_SetValue(dac_value);

        // Set LED intensity
        LED_SetIntensity(dac_value);

        // Display DAC value
        sprintf(uart_buffer, "DAC Value: %lu\r\n", dac_value);
        UART_Transmit(uart_buffer);
    }
}

uint32_t Calculate_nCr(uint32_t n, uint32_t r)
{
    if (r > n) return 0;
    if (r == 0 || r == n) return 1;

    uint32_t numerator = 1;
    for (uint32_t i = n; i > n - r; i--)
    {
        numerator *= i;
    }

    uint32_t denominator = 1;
    for (uint32_t i = 2; i <= r; i++)
    {
        denominator *= i;
    }

    return numerator / denominator;
}


void UART_Init(void)
{
    // Enable UART and GPIO clocks
    RCC->APB1ENR |= RCC_APB1ENR_USART2EN;
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;

    // Configure PA2 (USART2 TX) and PA3 (USART2 RX)
    GPIOA->MODER |= (0x2 << (2 * 2)) | (0x2 << (3 * 2)); // Alternate function mode
    GPIOA->AFR[0] |= (0x7 << (4 * 2)) | (0x7 << (4 * 3)); // AF7 (USART2)

    // Configure USART2
    USART2->BRR = 0x0683; // 9600 baud @ 16 MHz
    USART2->CR1 |= USART_CR1_TE | USART_CR1_RE; // Enable TX and RX
    USART2->CR1 |= USART_CR1_UE; // Enable USART
}

void UART_Transmit(char *string)
{
    for (size_t i = 0; i < strlen(string); i++)
    {
        while (!(USART2->SR & USART_SR_TXE)); // Wait for TX buffer to be empty
        USART2->DR = string[i]; // Transmit character
    }
}

void UART_Receive(char *buffer, uint32_t length)
{
    for (uint32_t i = 0; i < length - 1; i++)
    {
        while (!(USART2->SR & USART_SR_RXNE)); // Wait for RX buffer to be full
        char c = USART2->DR; // Receive character
        while (!(USART2->SR & USART_SR_TXE)); // Wait for TX buffer to be empty
        USART2->DR = c; // Echo character back

        if (c == '\n' || c == '\r')
        {
            buffer[i] = '\0'; // Null-terminate string
            return;
        }
        buffer[i] = c;
    }
    buffer[length - 1] = '\0'; // Null-terminate string
}